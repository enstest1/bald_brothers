import cron from "node-cron";
import { createClient } from "@supabase/supabase-js";
import { ChapterAgent } from "../../src/agents/chapterAgent";
const log = require("pino")();

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_ANON_KEY!
);

let isProcessingPollClosure = false;

async function createNextPoll(newChapterBody: string) {
    log.info("[Scheduler] Creating the next poll based on new chapter...");
    // For now, we will keep the poll options simple for stability.
    // In the future, this can also be generated by an AI.
    let choices = ["Forge ahead into the unknown", "Pause to reflect on their baldness"]; 
    
    await supabase.from("polls").insert({
        question: "What happens next?",
        options: choices,
        closes_at: new Date(Date.now() + 40000) // 40 seconds for testing
    });
    log.info("[Scheduler] Next poll has been created with options:", choices);
}

export async function closePollAndTally() {
  if (isProcessingPollClosure) {
    log.warn("[Scheduler] Cycle already running. Skipping.");
    return;
  }
  isProcessingPollClosure = true;
  log.info("--- [Scheduler] Starting Cycle ---");

  try {
    const { data: pollToProcess, error } = await supabase
        .from('polls')
        .select('*')
        .lt('closes_at', new Date().toISOString())
        .is('processed_at', null)
        .order('closes_at', { ascending: true })
        .limit(1)
        .single();

    if (error || !pollToProcess) {
        log.info("[Scheduler] No closed polls to process. Ending cycle.");
    } else {
        log.info(`[Scheduler] Processing poll ID ${pollToProcess.id}`);
        await supabase.from('polls').update({ processed_at: new Date().toISOString() }).eq('id', pollToProcess.id);
        
        const { data: votes } = await supabase.from("votes").select("choice").eq("poll_id", pollToProcess.id);
        const voteCounts = (pollToProcess.options as string[]).map((option, index) => ({ option, count: votes?.filter(v => v.choice === index).length || 0 }));
        
        // Handle no-vote scenarios by defaulting to the first option
        const winner = voteCounts.length > 0 ? voteCounts.reduce((a, b) => (b.count >= a.count ? b : a)) : { option: pollToProcess.options[0], count: 0 };
        log.info(`[Scheduler] Poll winner is "${winner.option}" with ${winner.count} votes.`);

        // --- DYNAMIC AI CHAPTER GENERATION ---
        // 1. Get the most recent story beat for context.
        const { data: lastChapter } = await supabase.from("beats").select("body").order("authored_at", { ascending: false }).limit(1).single();
        const storyContext = lastChapter?.body || "The story has just begun.";

        // 2. Construct a detailed prompt for the AI.
        const prompt = `The last chapter ended like this: "${storyContext}"\n\nThe community voted for the following to happen next: "${winner.option}".\n\nWrite the next chapter of the Bald Brothers saga, incorporating this choice. The chapter should be a few paragraphs long and end on a note of suspense or a new crossroad.`;

        log.info("[Scheduler] Generating new chapter with AI...");
        // 3. Run the AI agent to generate the next chapter.
        const result = await ChapterAgent.run(prompt);

        // 4. Use the AI-generated body, with a fallback if it fails.
        let newChapterBody = "The chronicles are faint, but the brothers' journey continues. A new path will soon be revealed.";
        if (result.success && typeof result.output === 'string' && result.output.length > 20) {
            newChapterBody = result.output;
            log.info("[Scheduler] AI chapter generated successfully.");
        } else {
            log.warn("[Scheduler] AI chapter generation failed or returned empty. Using fallback text.");
        }
        // --- END OF DYNAMIC LOGIC ---

        await supabase.from("beats").insert({ arc_id: "1", body: newChapterBody });
        log.info("[Scheduler] New chapter saved.");

        await createNextPoll(newChapterBody);
    }
  } catch (e) {
    if(e instanceof Error) log.error(e, "[Scheduler] Unhandled error in scheduler cycle.");
  } finally {
    isProcessingPollClosure = false;
    log.info("--- [Scheduler] Cycle Finished ---");
  }
}

export function startPollScheduler() {
  const cronIntervalSeconds = 35;
  log.info(`[Scheduler] Initializing. Polling interval: ${cronIntervalSeconds} seconds.`);
  cron.schedule(`*/${cronIntervalSeconds} * * * * *`, closePollAndTally);
  log.info("[Scheduler] Poll scheduler started.");
}

// Allow manual execution for testing
if (require.main === module) {
  log.info("Running poll closure manually");
  closePollAndTally().then(() => {
    log.info("Manual poll closure completed");
    process.exit(0);
  }).catch((error) => {
    log.error(error instanceof Error ? error.message : String(error), "Manual poll closure failed");
    process.exit(1);
  });
}

// Ensure poll durations are at least 30s in dev/test
const pollDuration = process.env.NODE_ENV === 'production' ? 24 * 60 * 60 * 1000 : 30 * 1000;